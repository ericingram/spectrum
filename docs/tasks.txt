application => spectrum
getInstance => getOnceInstance
Move SpecItem methods to SpecItemIt

результат выполнения
	написать про результат выполнения запуска контекстов и откдюченных спеков

Структура отлова исключения
после выброса исключения дальнейшее исполбзование объекта не предполагается

SpecItemIt (команда конструирования it()) ловит следующие исключения и php ошибки:
Execution - отлов исключений, выброшенных в любом из нижеперечисленных мест
	WorldBuilding
		onTestCallbackCallBefore
			TestCallback
		onTestCallbackCallAfter
	WorldDestroying

Assert->CallMatcher (в любом из мест Execution)
Притом, отлов исключений, выброшенных матчерами происходит непосредственно в функции вызова матчера класса Assert (что позволяет продолжатб выполнение теста после исключения матчера)

runResultsBuffer - result vs value vs resultValue

запретить getCurrentContainer/Spec на running state?

runner.php?file=
--- Написать PHPDOC комментарии

---Плагин report
// debug mode - просмотр порядка применения креаторов - возможно путем проверки идентичности callback
Command::addMessageToReport(); - возможность занесения в отчет всех print'ов

---commands
isRunningState - проверять наличие RunResultsBuffer (может быть вызван откуда то еще?), протестировать возможность вызова из событий

---examples
addExample('Автомобиль', $doorsCount);
itLikeExample('Автомобиль', 4);
что бы работало в контекстах надо выполнять itLikeExample во время выполнения
SpecContainerDynamic/SpecDynamic
ContainerExample
ContainerDynamic/LateBind - содержит callback ф-ю, которая возвращает Spec, который запускается
addExample('foo', function(){
	return new SpecItemIt('я пример');
});

function itLikeExample('foo')
{
	return new SpecContainerDynamic(function(){
		$exampleCallback = $this->examples->get('foo')
		return $exampleCallback();
	})
}

SpecContainerDynamic->run()
	вызвать callback ф-ю, которая вернет Spec
	запустить Spec (внутри run будет вызваны builders для каждого созданного динамически спеки и динамич спеки выполнятся правильно)



---asserts
Изменить синтаксис утверждений на более минималистический:
be('actual')->true();
be('actual')->not->null();
be('actual')->fileExists();
// может быть даже так (без скобок), нет лучше оставить подобное поведение для простанств имен
be('actual')->true;

---assert, matcher namespaces
addMatcher('file->exists', function(){});
be('actual value')->file('new File')->exists();

--- assert, счетчик вызовов
Command::expectCount();
incrementCount()
count(getRunningInstance()->getResultStack())


---errorHandling
получать текущее значение из контекста каскадом
Продумать возможность изменения errorHandler изнутри теста
	добавить доп. параметр в команду конструирования it(), describe(), context()
	проверять если последний параметр не callback, значит это level
	либо принимать последним параметром массив опций
	лучше совместить - можно либо массив опций либо значение level


setCatchExceptions - возможность указывать массив отлавливаемых классов исключений

---before
beforeAll - выполняется перед всеми в nearestDescribe всех его контекстов
beforeOnce
ifFirstChild()
beforeAll() vs beforeGroup()

--- Доработать тесты

---
includeSpec('./') - брать путь к текущей папке из backtrace

--- events
Assert->callMatcher
	$it->triggerEvent('onMatcherCallBefore', $this, $expectedArgs);
	$it->triggerEvent('onMatcherCallAfter', $this, $expectedArgs, $result);

---extensions
Spec->loadExtension()
LoadExtensionPatterns
loadExtensionWorld
spec->addExtensionPath
spec->addExtensionDir

---context
run($contextStackId)
контекст стек или снимок уид
getContextByStackUid
getSpecByUid

--- mock
Spy
FileSystemMockReal
FileSystemMockVirtual

--- world()
Лучше $world, т.к.:
	- обеспечивает защиту мира (ф-я world() может быть вызвана из глубин тестируемого кода)
	- будет стимулировать не использовать мир в матчерах
	- в examples мир по любому не может быть вызван
	
// selector
//todo: select by stack uid
получить спеки из дерева
результаты
	добавить из owner spec
	добавить из результатов spec
	отфильтровать

операции с текущим результатом
	просмотреть каждый объект в результате и удалиль лишние filterEnabled
	выбрать из каждого объекта в результате и добавить в результат findContextsInResult
	выбрать из owner спеки и добавить в результат findCurrentSpecChildren

addSelf->findDescendants->findAncestors->filterEnabled->filterContexts
find('descendants', 'ancestors')->filter('enabled')->get('contexts')->getFromResult('context')


selector->getSelf()->getDescendants()->filterEnabled()
selector->getNearestParentDescribe()->filterIts()

//spectrum_DefaultMatchers_Base_beInstanceOf
beTriggerError(level)/bePhpError

//spectrum_DefaultMatchers_Base_BeBool
//spectrum_DefaultMatchers_Base_BeInt
//spectrum_DefaultMatchers_Base_BeFloat
//spectrum_DefaultMatchers_Base_BeNumber
//spectrum_DefaultMatchers_Base_BeString
//spectrum_DefaultMatchers_Base_BeScalar
//spectrum_DefaultMatchers_Base_BeArray
//spectrum_DefaultMatchers_Base_BeObject
//spectrum_DefaultMatchers_Base_BeCallback
//spectrum_DefaultMatchers_Base_BeClosure
//spectrum_DefaultMatchers_Base_BeCallable
//spectrum_DefaultMatchers_Base_BeResource
/*
* spectrum_DefaultMatchers_File_BeFileExists
* spectrum_DefaultMatchers_File_BeFileContentEqual
* spectrum_DefaultMatchers_File_BeFileIsDir
* spectrum_DefaultMatchers_File_BeFileIsFile
* spectrum_DefaultMatchers_File_BeFileIsLink
* spectrum_DefaultMatchers_File_BeFileIsExecutable
* spectrum_DefaultMatchers_File_BeFileIsReadable
* spectrum_DefaultMatchers_File_BeFileIsUploaded
* spectrum_DefaultMatchers_File_BeFileIsWritable
 *
 *
 *
* spectrum_DefaultMatchers_Array_BeArrayHasKey
* spectrum_DefaultMatchers_Array_BeArrayHasValue
* spectrum_DefaultMatchers_Array_BeArrayHasAllKeys
* spectrum_DefaultMatchers_Array_BeArrayHasAllValues
* spectrum_DefaultMatchers_Array_BeArrayHasAnyKey
* spectrum_DefaultMatchers_Array_BeArrayHasAnyValue
* spectrum_DefaultMatchers_Array_BeArrayUnsortedEqual
* spectrum_DefaultMatchers_Array_BeArrayUnsortedEqualRecursive
* spectrum_DefaultMatchers_Array_BeArrayUnsortedIdentical
* spectrum_DefaultMatchers_Array_BeArrayUnsortedIdenticalRecursive
* spectrum_DefaultMatchers_Array_BeArrayCountEqual
 *
*
* spectrum_DefaultMatchers_String_BeStringContain
* spectrum_DefaultMatchers_String_BeStringContainInPosition
* spectrum_DefaultMatchers_String_BeStringStartWith
* spectrum_DefaultMatchers_String_BeStringEndWith
* spectrum_DefaultMatchers_File_BeStringEndWithAnySlash
* spectrum_DefaultMatchers_File_BeStringStartWithAnySlash
*
* spectrum_DefaultMatchers_RegExp_BePregMatch
 *
 * spectrum_DefaultMatchers_Xml_BeXmlWellFormed
 * spectrum_DefaultMatchers_Xml_BeXmlValid
 *
 * spectrum_DefaultMatchers_Html_BeHtmlAttributeEqual
 * spectrum_DefaultMatchers_Html_BeHtmlContainTag
 * spectrum_DefaultMatchers_Html_BeHtmlCorrect
 * spectrum_DefaultMatchers_Html_BeHtmlWellFormed
 * spectrum_DefaultMatchers_Html_BeHtmlValid
 *
 *














describe(function(){
	context('context 2', function(){
	  -> describe(function(){
		 -> context('context 2', function(){
				it('test 2');
			 -> context('context 1', function(){
					it('test 2');
				});
			});

			context('context 1', function(){});

			it('test 2');
		}

		it('test 2');
	});
});

  -> describe(function(){
		context('context 1', function(){});
	 -> context('context 2', function(){
		 -> context('context 1', function(){});
		});

	  -> describe(function(){
		 -> context('context 2', function(){
				it('test 2');
			 -> context('context 1', function(){
					it('test 2');
				});

			 context('context 1', function(){
					it('test 2');
				});
			});

			context('context 1', function(){});

			it('test 2', function($w){
				world()->foo = bar
				getRunningInstance()::getWorld()
			});
		}
	})




describe(function(){
	context('context 1', function(){});
	context('context 2', function(){});

	describe(function(){
		context('context 2', function(){
			it('test 1');
		 -> context('context 4', function(){});
			context('context 3', function(){});
		});

		context('context 1', function(){});

		it('test 2');
	}
})


describe(function(){
	beforeEach(1);
	beforeEach(2);

	afterEach(33);
	afterEach(44);
	
	describe(function(){
		beforeEach(3);
		beforeEach(4);
		it()
		afterEach(11);
		afterEach(22);

		context('context 0', function(){
			context('context 1', function(){
				beforeEach();
			});

			context('context 2', function(){
				beforeEach();

				it('test 1');

			});
		});

		context('context 3', function(){
			beforeEach();
		});

		it('test 1');
		it('test 2');
		it('test 3');
	})

	it('test 1');
	it('test 2');
	it('test 3');
})


describe(function(){
	beforeEach();

	context('context 2', function(){
		beforeEach();

		context('context 1', function(){
			beforeEach();
		});

        it('test 1');

	});

	describe('test 1');
	it('test 2');
	it('test 3');
})


describe(function(){
	describe('context 1', function(){
		beforeEach();

		it('test 1');
		it('test 2');
		it('test 3');
	});

	describe('context 2', function(){
		beforeEach();

		it('test 1');
		it('test 2');
		it('test 3'); // Ohh... one more copy/paste
	});
})





describe(function(){

	context('', function(){
		beforeEach();
	});

	context('context 2', function(){
		beforeEach();
	});

	it('test 1');
	it('test 2');
	it('test 3');
})


describe(function(){
	describe('context group', function(){
		beforeEach();

		it('test 1');
		it('test 2');
		it('test 3');

		describe('context 1', function(){
			beforeEach();

			it('test 1');
			it('test 2');
			it('test 3');
		});

		describe('context 2', function(){
			beforeEach();

			it('test 1');
			it('test 2');
			it('test 3');
		});
	});
})